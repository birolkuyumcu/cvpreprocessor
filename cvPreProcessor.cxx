//
// cvPreProcessor, Visual Tool for OpenCv
// Copyright (C) 2008  BlueKid
// GUI tool for OpenCv 
// Programmed by BlueKid");
//  http://derindelimavi.blogspot.com/");
// Please Send me any suggestion, modification or bugs.");
// Don't hesitate to contact me for any question");
// I will be very grateful with your feedbacks.");
// bluekid70@gmail.com
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//

// generated by Fast Light User Interface Designer (fluid) version 1.0109

#include "cvPreProcessor.h"
const char Version[]="cvPreProcessor 0.90"; 
IplImage *img,*pimg,*timg; 
IplImage *mimg; 
Fl_OpenCV *orj,*proc; 
Processor *p; 

Fl_Color fl_hsv_color(double H, double S, double V) {
  double R, G, B;

H=H/30;
S=S/255;
V=V/255;
if(H>S)
 V=H;
else
 V=S;

if (S < 5.0e-6) {
    R = G = B = V;
  } else {
    int i = (int)H;  
    double f = H - (float)i;
    double p1 = V*(1.0-S);
    double p2 = V*(1.0-S*f);
    double p3 = V*(1.0-S*(1.0-f));
    switch (i) {
    case 0: R = V;   G = p3;  B = p1;  break;
    case 1: R = p2;  G = V;   B = p1;  break;
    case 2: R = p1;  G = V;   B = p3;  break;
    case 3: R = p1;  G = p2;  B = V;   break;
    case 4: R = p3;  G = p1;  B = V;   break;
    case 5: R = V;   G = p1;  B = p2;  break;
    }
  }
  return fl_rgb_color(255*R,255*G,255*B);
}

Fl_Group *Before=(Fl_Group *)0;

Fl_Group *After=(Fl_Group *)0;

static void cb_(Fl_Button*, void*) {
  p->CopyTo1();
}

static void cb_1(Fl_Button*, void*) {
  p->Load1();
}

Fl_Button *MemorySet1=(Fl_Button *)0;

static void cb_MemorySet1(Fl_Button*, void*) {
  p->CopyToMemory(1);
MemoryGet1->activate();
MemoryGet2->activate();
}

Fl_Button *MemoryGet1=(Fl_Button *)0;

static void cb_MemoryGet1(Fl_Button*, void*) {
  p->CopyFromMemory(1);
}

Fl_Button *MemorySet2=(Fl_Button *)0;

static void cb_MemorySet2(Fl_Button*, void*) {
  p->CopyToMemory(2);
MemoryGet1->activate();
MemoryGet2->activate();
}

static void cb_2(Fl_Button*, void*) {
  p->Load2();
}

Fl_Button *MemoryGet2=(Fl_Button *)0;

static void cb_MemoryGet2(Fl_Button*, void*) {
  p->CopyFromMemory(2);
}

static void cb_Open(Fl_Menu_*, void*) {
  p->Load1();
}

static void cb_Save(Fl_Menu_*, void*) {
  p->Save1();
}

static void cb_Open1(Fl_Menu_*, void*) {
  p->Load2();
}

static void cb_Save1(Fl_Menu_*, void*) {
  p->Save2();
}

static void cb_Clear(Fl_Menu_*, void*) {
  p->Clear();
}

static void cb_Undo(Fl_Menu_*, void*) {
  p->Undo();
}

static void cb_Save2(Fl_Menu_*, void*) {
  p->SaveCode();
}

static void cb_Exit(Fl_Menu_*, void*) {
  exit(0);
}

static void cb_Resize(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
ReSizeForm *op=new ReSizeForm();
op->show();
}

static void cb_Rotate(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
RotateForm *op=new RotateForm();
op->show();
}

static void cb_Histogram(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
HistForm *op=new HistForm();
op->show();
}

static void cb_RGB(Fl_Menu_*, void*) {
  p->RGBToGray();
}

static void cb_Split(Fl_Menu_*, void*) {
  p->SRed();
}

static void cb_Split1(Fl_Menu_*, void*) {
  p->SGreen();
}

static void cb_Split2(Fl_Menu_*, void*) {
  p->SBlue();
}

static void cb_Split3(Fl_Menu_*, void*) {
  p->SHue();
}

static void cb_Split4(Fl_Menu_*, void*) {
  p->SSaturation();
}

static void cb_Equalizes(Fl_Menu_*, void*) {
  p->EHist();
}

static void cb_Normal(Fl_Menu_*, void*) {
  p->NormalThreshold();
}

static void cb_Adaptive(Fl_Menu_*, void*) {
  p->AdaptiveThreshold();
}

static void cb_Options(Fl_Menu_*, void*) {
  ThresholdOptions *op=new ThresholdOptions();
op->show();
}

static void cb_Erode(Fl_Menu_*, void*) {
  p->Erode();
}

static void cb_Dilate(Fl_Menu_*, void*) {
  p->Dilate();
}

static void cb_Open2(Fl_Menu_*, void*) {
  p->Open();
}

static void cb_Close(Fl_Menu_*, void*) {
  p->Close();
}

static void cb_Gradient(Fl_Menu_*, void*) {
  p->Grad();
}

static void cb_Top(Fl_Menu_*, void*) {
  p->TopHat();
}

static void cb_Black(Fl_Menu_*, void*) {
  p->BlackHat();
}

static void cb_Options1(Fl_Menu_*, void*) {
  MorphOptions *op=new MorphOptions();
op->show();
}

static void cb_Sobel(Fl_Menu_*, void*) {
  p->Sobel();
}

static void cb_Laplace(Fl_Menu_*, void*) {
  p->Laplace();
}

static void cb_Canny(Fl_Menu_*, void*) {
  p->Canny();
}

static void cb_Options2(Fl_Menu_*, void*) {
  EdgeOptions *op=new EdgeOptions();
op->show();
}

static void cb_Add(Fl_Menu_*, void*) {
  p->Add();
}

static void cb_Subtract(Fl_Menu_*, void*) {
  p->Sub();
}

static void cb_Multiply(Fl_Menu_*, void*) {
  p->Mul();
}

static void cb_Division(Fl_Menu_*, void*) {
  p->Div();
}

static void cb_Max(Fl_Menu_*, void*) {
  p->Max();
}

static void cb_Min(Fl_Menu_*, void*) {
  p->Min();
}

static void cb_Absolute(Fl_Menu_*, void*) {
  p->AbsDiff();
}

static void cb_Equal(Fl_Menu_*, void*) {
  p->Compare(0);
}

static void cb_Greater(Fl_Menu_*, void*) {
  p->Compare(1);
}

static void cb_Greater1(Fl_Menu_*, void*) {
  p->Compare(2);
}

static void cb_Less(Fl_Menu_*, void*) {
  p->Compare(3);
}

static void cb_Less1(Fl_Menu_*, void*) {
  p->Compare(4);
}

static void cb_Not(Fl_Menu_*, void*) {
  p->Compare(5);
}

static void cb_And(Fl_Menu_*, void*) {
  p->And();
}

static void cb_Or(Fl_Menu_*, void*) {
  p->Or();
}

static void cb_Xor(Fl_Menu_*, void*) {
  p->Xor();
}

static void cb_Not1(Fl_Menu_*, void*) {
  p->Not();
}

static void cb_Smooth(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
SmoothForm *frm=new SmoothForm();
frm->show();
}

static void cb_Filter2D(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
Filter2DForm *frm=new Filter2DForm();
frm->show();
}

static void cb_Color(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
if(img->nChannels!=3){
  fl_alert("Source image must me color");
  return; 
}
HSFilterForm *frm=new HSFilterForm();
frm->show();
}

static void cb_Color1(Fl_Menu_*, void*) {
  if(img==NULL)   return;  
if(img->nChannels!=3){
  fl_alert("Source image must me color");
  return; 
}
RGBFilterForm *frm=new RGBFilterForm();
frm->show();
}

static void cb_About(Fl_Menu_*, void*) {
  AboutDlg *ab=new AboutDlg();
ab->show();
}

Fl_Menu_Item menu_[] = {
 {"File", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Image 1", 0,  (Fl_Callback*)cb_Open, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save  Image 1", 0,  (Fl_Callback*)cb_Save, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open Image 2", 0,  (Fl_Callback*)cb_Open1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save  Image 2", 0,  (Fl_Callback*)cb_Save1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Clear All", 0,  (Fl_Callback*)cb_Clear, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Undo", 0xff08,  (Fl_Callback*)cb_Undo, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Save Code", 0,  (Fl_Callback*)cb_Save2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Exit", 0,  (Fl_Callback*)cb_Exit, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Image", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Resize", 0,  (Fl_Callback*)cb_Resize, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Rotate", 0,  (Fl_Callback*)cb_Rotate, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Histogram + Statistics", 0,  (Fl_Callback*)cb_Histogram, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Color", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"RGB To Gray", 0,  (Fl_Callback*)cb_RGB, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Red", 0,  (Fl_Callback*)cb_Split, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Green", 0,  (Fl_Callback*)cb_Split1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Blue", 0,  (Fl_Callback*)cb_Split2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Hue", 0,  (Fl_Callback*)cb_Split3, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Split Saturation", 0,  (Fl_Callback*)cb_Split4, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Equalizes histogram", 0,  (Fl_Callback*)cb_Equalizes, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Threshold", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Normal", 0,  (Fl_Callback*)cb_Normal, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Adaptive", 0,  (Fl_Callback*)cb_Adaptive, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Options", 0,  (Fl_Callback*)cb_Options, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {"Morphology", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Erode", 0,  (Fl_Callback*)cb_Erode, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Dilate", 0,  (Fl_Callback*)cb_Dilate, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Open", 0,  (Fl_Callback*)cb_Open2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Close", 0,  (Fl_Callback*)cb_Close, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Gradient", 0,  (Fl_Callback*)cb_Gradient, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Top hat", 0,  (Fl_Callback*)cb_Top, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Black hat", 0,  (Fl_Callback*)cb_Black, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Options", 0,  (Fl_Callback*)cb_Options1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Edge Detections", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Sobel", 0,  (Fl_Callback*)cb_Sobel, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Laplace", 0,  (Fl_Callback*)cb_Laplace, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Canny", 0,  (Fl_Callback*)cb_Canny, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Options", 0,  (Fl_Callback*)cb_Options2, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Arithmetical", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Add", 0x8002b,  (Fl_Callback*)cb_Add, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Subtract", 0x8002d,  (Fl_Callback*)cb_Subtract, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Multiply", 0x8002a,  (Fl_Callback*)cb_Multiply, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Division", 0x8002f,  (Fl_Callback*)cb_Division, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Max", 0,  (Fl_Callback*)cb_Max, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Min", 0,  (Fl_Callback*)cb_Min, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Absolute Diff", 0,  (Fl_Callback*)cb_Absolute, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Compare", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Equal to", 0,  (Fl_Callback*)cb_Equal, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Greater than", 0,  (Fl_Callback*)cb_Greater, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Greater or Equal", 0,  (Fl_Callback*)cb_Greater1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Less than", 0,  (Fl_Callback*)cb_Less, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Less or Equal", 0,  (Fl_Callback*)cb_Less1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Not Equal to", 0,  (Fl_Callback*)cb_Not, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0},
 {"Logical", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"And", 0,  (Fl_Callback*)cb_And, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Or", 0,  (Fl_Callback*)cb_Or, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Xor", 0,  (Fl_Callback*)cb_Xor, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Not", 0,  (Fl_Callback*)cb_Not1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Filtering", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"Smooth", 0,  (Fl_Callback*)cb_Smooth, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Filter2D", 0,  (Fl_Callback*)cb_Filter2D, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Color - HS", 0,  (Fl_Callback*)cb_Color, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {"Color RGB", 0,  (Fl_Callback*)cb_Color1, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {"Help", 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {"About", 0,  (Fl_Callback*)cb_About, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

Fl_Browser *Output=(Fl_Browser *)0;

Fl_Double_Window* make_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = new Fl_Double_Window(1064, 678, "cvPreProcessor");
    w = o;
    o->color((Fl_Color)31);
    o->labelcolor((Fl_Color)1);
    { Fl_Group* o = new Fl_Group(10, 50, 1044, 364);
      { Before = new Fl_Group(10, 50, 484, 364, "Image 1 ( img )");
        Before->box(FL_EMBOSSED_BOX);
        Before->color((Fl_Color)31);
        Before->align(FL_ALIGN_TOP_LEFT);
        orj=new Fl_OpenCV(12,52,480,320);
        orj->FitWindows();
        Before->end();
      } // Fl_Group* Before
      { After = new Fl_Group(570, 50, 484, 364, "Image 2 ( pimg )");
        After->box(FL_EMBOSSED_BOX);
        After->color((Fl_Color)31);
        After->align(FL_ALIGN_TOP_LEFT);
        proc=new Fl_OpenCV(572,52,480,320);
        proc->FitWindows();
        After->end();
      } // Fl_Group* After
      { Fl_Button* o = new Fl_Button(505, 210, 55, 26, "@<-");
        o->box(FL_GTK_UP_BOX);
        o->color((Fl_Color)21);
        o->labelcolor((Fl_Color)3);
        o->callback((Fl_Callback*)cb_);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(495, 50, 30, 20, "...");
        o->tooltip("Open File");
        o->box(FL_GTK_THIN_UP_BOX);
        o->color((Fl_Color)21);
        o->callback((Fl_Callback*)cb_1);
      } // Fl_Button* o
      { MemorySet1 = new Fl_Button(495, 81, 30, 25, "@-> M");
        MemorySet1->tooltip("Copy to Memory");
        MemorySet1->box(FL_GTK_THIN_UP_BOX);
        MemorySet1->color((Fl_Color)21);
        MemorySet1->labelsize(10);
        MemorySet1->labelcolor((Fl_Color)1);
        MemorySet1->callback((Fl_Callback*)cb_MemorySet1);
      } // Fl_Button* MemorySet1
      { MemoryGet1 = new Fl_Button(495, 116, 30, 25, "@<-  M");
        MemoryGet1->tooltip("Copy form Memory");
        MemoryGet1->box(FL_GTK_THIN_UP_BOX);
        MemoryGet1->color((Fl_Color)21);
        MemoryGet1->labelsize(10);
        MemoryGet1->labelcolor((Fl_Color)1);
        MemoryGet1->callback((Fl_Callback*)cb_MemoryGet1);
        MemoryGet1->deactivate();
      } // Fl_Button* MemoryGet1
      { MemorySet2 = new Fl_Button(540, 285, 30, 25, "M @<-");
        MemorySet2->tooltip("Copy to Memory");
        MemorySet2->box(FL_GTK_THIN_UP_BOX);
        MemorySet2->color((Fl_Color)21);
        MemorySet2->labelsize(10);
        MemorySet2->labelcolor((Fl_Color)1);
        MemorySet2->callback((Fl_Callback*)cb_MemorySet2);
      } // Fl_Button* MemorySet2
      { Fl_Button* o = new Fl_Button(540, 260, 30, 20, "...");
        o->tooltip("Open File");
        o->box(FL_GTK_THIN_UP_BOX);
        o->color((Fl_Color)21);
        o->callback((Fl_Callback*)cb_2);
      } // Fl_Button* o
      { MemoryGet2 = new Fl_Button(540, 315, 30, 25, "M @->");
        MemoryGet2->tooltip("Copy form Memory");
        MemoryGet2->box(FL_GTK_THIN_UP_BOX);
        MemoryGet2->color((Fl_Color)21);
        MemoryGet2->labelsize(10);
        MemoryGet2->labelcolor((Fl_Color)1);
        MemoryGet2->callback((Fl_Callback*)cb_MemoryGet2);
        MemoryGet2->deactivate();
      } // Fl_Button* MemoryGet2
      o->end();
    } // Fl_Group* o
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 1064, 25);
      o->box(FL_GTK_UP_BOX);
      o->color((Fl_Color)19);
      o->menu(menu_);
    } // Fl_Menu_Bar* o
    { Output = new Fl_Browser(10, 424, 1044, 244);
      Output->type(3);
      Output->box(FL_DOWN_BOX);
      Output->color((Fl_Color)19);
    } // Fl_Browser* Output
    o->label(Version);
    o->end();
  } // Fl_Double_Window* o
  return w;
}

int main(int argc, char **argv) {
  Fl_Window  * window;
  img=0;
  window = make_window( );
  window->show( argc, argv );
  p= new Processor();
  return Fl::run();
}

Processor::Processor() {
  m.iterations=1;
  m.cols=3;
  m.rows=3;
  m.anchor_x=2;
  m.anchor_y=2;
  m.shape=CV_SHAPE_RECT;

  ed.aperture=0;
  ed.xOrder=1;
  ed.yOrder=0;
  ed.tmin=50;
  ed.tmax=150;

  th.thresh=128;
  th.maxVal=255;
  th.type=CV_THRESH_BINARY;
  th.method=CV_ADAPTIVE_THRESH_MEAN_C;
  th.block_size=3;
  th.param1=5;
  th.otsu=0;
  r.ratio=100;  
  r.rwidth=0;
  r.rheight=0;  
  r.aspect=1;
  
  sm.type=1;
  sm.size1=3;
  sm.size2=0;
  sm.sigma1=0.0;
  sm.sigma2=0.0;
  
  uimg=NULL;
  upimg=NULL;
  undo=false;
  
  flt.col=3;
  flt.row=3;
  flt.anchorx=-1;
  flt.anchory=-1;
  for(int i=0;i<81;i++)flt.data[i]=0.0;
  
  Clear();
}

void Processor::FixFilename(char *src, char *dst) {
  int j=0;
  for(int i=0; i<1024 ;i++){
    dst[j]=src[i];
    j++;
    if(src[i]==0) break;
    if(src[i]=='/') dst[j++]='/';
   
  }
}

void Processor::CopyTo1() {
  if(pimg){
    img=cvCloneImage(pimg);
    orj->SetImage(img);
    Before->redraw();
  
    Output->add("");
    Output->add("/* Copy Image2 to Image1 */");
    Output->add("  if(img)"); 
    Output->add("    cvReleaseImage(&img);");
    Output->add("  img=cvCloneImage(pimg);"); 
    Output->bottomline(Output->size());
  }
}

void Processor::CopyFromMemory(int i) {
  if(i==1){ 
    if(mimg){
      img=cvCloneImage(mimg);
      orj->SetImage(img);
      Before->redraw();
  
      Output->add("");
      Output->add("/* Copy from Memory to Image1 */");
      Output->add("  if(img)"); 
      Output->add("    cvReleaseImage(&img);");
      Output->add("  img=cvCloneImage(mimg);"); 
      Output->bottomline(Output->size());
    }
  }  
  else{ 
    if(mimg){
      pimg=cvCloneImage(mimg);
      proc->SetImage(pimg);
      After->redraw();
  
      Output->add("");
      Output->add("/* Copy from Memory to Image2 */");
      Output->add("  if(pimg)"); 
      Output->add("    cvReleaseImage(&pimg);");
      Output->add("  pimg=cvCloneImage(mimg);"); 
      Output->bottomline(Output->size());
    }
  }
}

void Processor::CopyToMemory(int i) {
  if(i==1){ 
    if(img){
      mimg=cvCloneImage(img);   
      Output->add("");
      Output->add("/* Copy Image1 to Memory */");
      Output->add("  if(mimg)"); 
      Output->add("    cvReleaseImage(&mimg);");
      Output->add("  mimg=cvCloneImage(img);"); 
      Output->bottomline(Output->size());
    }
  }
  else{
    if(pimg){
      mimg=cvCloneImage(pimg);   
      Output->add("");
      Output->add("/* Copy Image2 to Memory */");
      Output->add("  if(mimg)"); 
      Output->add("    cvReleaseImage(&mimg);");
      Output->add("  mimg=cvCloneImage(pimg);"); 
      Output->bottomline(Output->size());
    }
  }
}

void Processor::SaveState() {
  usize=Output->size();
  if(uimg)
    cvReleaseImage(&uimg);
  if(upimg)
    cvReleaseImage(&upimg);  
  
  if(img)
    uimg=cvCloneImage(img);
  if(pimg) 
    upimg=cvCloneImage(pimg);
  undo=true;
}

void Processor::Undo(bool full) {
  if(undo==false) return;
 if(full){
    img=uimg;
    orj->SetImage(img);
    Before->redraw();
    uimg=NULL;
 }

 pimg=upimg;
 proc->SetImage(pimg);
 After->redraw();
 upimg=NULL;


//  if(usize){  
    while(usize < Output->size())
       Output->remove(Output->size());
    usize=0;
//  }
  undo=false;
  
  Output->bottomline(Output->size());
}

void Processor::Load1() {
  char* file;

  file = fl_file_chooser("Open", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;

  SaveState();
  orj->Load(file, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR ); 
  img=orj->image;
// Board->redraw();
  Before->redraw();


  char Buf[1024];
  char Buf2[1024];
  Output->add("");
  Output->add("/* Loads Images */");
  Output->add("  if(img)"); 
  Output->add("    cvReleaseImage(&img);");
  sprintf(Buf,"  img=cvLoadImage( %c%s %c, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR  );",'"',file,'"');
  FixFilename(Buf,Buf2);
  Output->add(Buf2);
  Output->bottomline(Output->size());
}

void Processor::Save1() {
  if(!img) return;
  char* file=NULL;
  file = fl_file_chooser("Save", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;
  orj->Save(file);

  char Buf[1024];
  char Buf2[1024];  
  Output->add("");
  Output->add("/* Save Image */");
  sprintf(Buf,"  cvSaveImage( %c%s %c,img );",'"',file,'"');
  FixFilename(Buf,Buf2);
  Output->add(Buf2);
  Output->bottomline(Output->size());
}

void Processor::Load2() {
  char* file;

  file = fl_file_chooser("Open", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;
  SaveState();
  proc->Load(file, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR ); 
  pimg=proc->image;
  After->redraw();

  
  char Buf[1024];
  char Buf2[1024];
  Output->add("");
  Output->add("/* Loads Images */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  sprintf(Buf,"  pimg=cvLoadImage( %c%s %c, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR  );",'"',file,'"');
  FixFilename(Buf,Buf2);
  Output->add(Buf2);
  Output->bottomline(Output->size());
}

void Processor::Save2() {
  if(!pimg) return;
  char* file=NULL;
  file = fl_file_chooser("Save", "Picture (*.{jpg,png,bmp,dib,sr,ras,pbm,pgm,ppm,tif,tiff})\t", 0);
  if(file==NULL) return;
  proc->Save(file);

  char Buf[1024];  
  char Buf2[1024];
  Output->add("");
  Output->add("/* Save Image */");
  sprintf(Buf,"  cvSaveImage( %c%s %c,pimg );",'"',file,'"');
  FixFilename(Buf,Buf2);
  Output->add(Buf2);
  Output->bottomline(Output->size());
}

void Processor::Clear() {
  orj->SetImage(NULL);
  proc->SetImage(NULL);
  Before->redraw();
  After->redraw();
  Output->clear();
  Output->clear();
  char Buf[512];
  sprintf(Buf,"/* This Code generated by %s */",Version);
  Output->add(Buf);
  Output->add("#include <cv.h>");
  Output->add("#include <highgui.h>");
  Output->add("#include <stdio.h>");  
  Output->add("");
  Output->add("IplImage* img,*pimg,*timg,*mimg;");
  Output->add("void Process();");
  Output->add("");
  Output->add("int main( )");
  Output->add("{");
  sprintf(Buf,"   puts(%cThis Code generated by %s%c);",'"',Version,'"');
  Output->add(Buf);
  Output->add("   Process();");
  Output->add("   if(img){");
  sprintf(Buf,"     cvNamedWindow( %cSource%c, 1 );",'"','"');
  Output->add(Buf);
  sprintf(Buf,"     cvShowImage( %cSource%c, img );",'"','"');
  Output->add(Buf);
  Output->add("   }");
  Output->add("   if(pimg){");
  sprintf(Buf,"     cvNamedWindow( %cProcessed Image%c, 1 );",'"','"');
  Output->add(Buf);
  sprintf(Buf,"     cvShowImage( %cProcessed Image%c, pimg );",'"','"');
  Output->add(Buf);
  Output->add("   }");
  Output->add("   cvWaitKey(0);");
  Output->add("");
  Output->add("   if(img)");
  Output->add("     cvReleaseImage(&img);");
  Output->add("   if(pimg)");
  Output->add("     cvReleaseImage(&pimg);");
  Output->add("");
  Output->add("}");
  Output->add("void Process()");
  Output->add("{");
  Output->bottomline(Output->size());
  img=NULL;
  pimg=NULL;
}

void Processor::SaveCode() {
  if(Output->size()<1) return;
  char* file=NULL;
  file = fl_file_chooser("Save Code ", "Code (*.{c,cpp,cxx,}\t", 0);
  if(file==NULL) return;

  if(file!=NULL){
    char Buf[1024];
    FILE *fp;
    fp=fopen(file,"wt");
    if(fp){
     for(int i=1;i<=Output->size();i++){
       sprintf(Buf,"%s\n",Output->text(i));
       fputs(Buf,fp);
     }
     fputs("}",fp);
     fclose(fp);   
     fl_message("Code Saved");      
    }

  }
}

void Processor::Exit() {
  exit(0);
}

void Processor::ReSize() {
  if(img==NULL)   return;  




  SaveState();
  pimg = cvCreateImage( cvSize(r.rwidth,r.rheight), img->depth, img->nChannels);

  cvResize( img, pimg, r.method);
  proc->SetImage(pimg);
  After->redraw();
  

  char *Methods[]= {"CV_INTER_NN",
 	            "CV_INTER_LINEAR",
		    "CV_INTER_AREA",
		    "CV_INTER_CUBIC"};
  char Buf[512];  
  
  Output->add(""); 
  Output->add("/* Resizing image  */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  sprintf(Buf,"  pimg = cvCreateImage( cvSize(%d,%d), %d, %d);",r.rwidth,r.rheight, img->depth, img->nChannels);
  Output->add(Buf);
  sprintf(Buf,"  cvResize( img, pimg, %s);",Methods[r.method]);
  Output->add(Buf);  
  Output->bottomline(Output->size());
}

void Processor::Rotate(int angle) {
  if(img==NULL)   return;  





  SaveState();
  pimg = cvCloneImage (img);

  float m[6];
  CvMat M;
  m[0] = (float) (cos (angle * CV_PI / 180.));
  m[1] = (float) (-sin (angle * CV_PI / 180.));
  m[2] = img->width * 0.5;
  m[3] = -m[1];
  m[4] = m[0];
  m[5] = img->height * 0.5;
  cvInitMatHeader (&M, 2, 3, CV_32FC1, m, CV_AUTOSTEP);
  cvGetQuadrangleSubPix (img, pimg, &M);
  proc->SetImage(pimg);
  After->redraw();
  

  char Buf[512];  
  
  Output->add(""); 
  Output->add("/* Rotating image  */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  sprintf(Buf,"  int angle= %d ;",angle);
  Output->add("    pimg = cvCloneImage (img);");  
  Output->add(Buf);
  Output->add("  float m[6];");
  Output->add("  CvMat M;");  
  Output->add("  m[0] = (float) (cos (angle * CV_PI / 180.));");
  Output->add("  m[1] = (float) (-sin (angle * CV_PI / 180.));");
  Output->add("  m[2] = img->width * 0.5;");
  Output->add("  m[3] = -m[1];");
  Output->add("  m[4] = m[0];");
  Output->add("  m[5] = img->height * 0.5;");
  Output->add("  cvInitMatHeader (&M, 2, 3, CV_32FC1, m, CV_AUTOSTEP);");  
  Output->add("  cvGetQuadrangleSubPix( img, pimg, &M); ");

  Output->bottomline(Output->size());
}

void Processor::RGBToGray() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvCvtColor( img, pimg, CV_RGB2GRAY );
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Converts image from color space ( RGB ) to a Gray Scale */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvCvtColor( img, pimg, CV_RGB2GRAY );");
  Output->bottomline(Output->size());
}

void Processor::SRed() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvSplit( img,pimg,0,0,0);
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Red Channel of image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvSplit( img,0,0,pimg,0);");
  Output->bottomline(Output->size());
}

void Processor::SGreen() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvSplit( img,0,pimg,0,0);
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Green Channel of image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvSplit( img,0,pimg,0,0);");
  Output->bottomline(Output->size());
}

void Processor::SBlue() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvSplit( img,0,0,pimg,0);
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Blue Channel of image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvSplit( img,pimg,0,0,0);");
  Output->bottomline(Output->size());
}

void Processor::SHue() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  timg = cvCreateImage( cvGetSize(img), 8, 3 );
  cvCvtColor( img, timg, CV_RGB2HSV );
  cvConvertScale(timg,timg, 255/180 ,0);
  cvSplit( timg,pimg,0,0,0);
  cvReleaseImage(&timg);
  proc->SetImage(pimg);
  After->redraw();

  Output->add(""); 
  Output->add("/* Split Hue Channel from HSV image to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  timg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 3 );");
  Output->add("  cvCvtColor( img, timg, CV_BGR2HSV );");
  Output->add("  cvConvertScale(timg,timg, 255.0/180.0 ,0);");
  Output->add("  cvSplit( timg,pimg,0,0,0);");
  Output->add("  cvReleaseImage(&timg);");
  Output->bottomline(Output->size());
}

void Processor::SSaturation() {
  if(img==NULL)   return;  
  if(img->nChannels!=3){ 
     fl_alert("image must be color");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  timg = cvCreateImage( cvGetSize(img), 8, 3 );
  cvCvtColor( img, timg, CV_RGB2HSV );
  cvSplit( timg,0,pimg,0,0);
  cvReleaseImage(&timg);

  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Split Saturation Channel from HSV to a Gray Scale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  timg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 3 );");
  Output->add("  cvCvtColor( img, timg, CV_BGR2HSV );");
  Output->add("  cvSplit( timg,0,pimg,0,0);");
  Output->add("  cvReleaseImage(&timg);");
  Output->bottomline(Output->size());
}

void Processor::EHist() {
  if(img==NULL)   return;  
  if(img->nChannels!=1){ 
     fl_alert("image must be a gray and single channel ");
     return;  
  }

  SaveState();  
  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );
  cvEqualizeHist(img,pimg );
  proc->SetImage(pimg);
  After->redraw();
  Output->add(""); 
  Output->add("/* Equalizes histogram of grayscale image */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage( cvGetSize(img), IPL_DEPTH_8U, 1 );");
  Output->add("  cvEqualizeHist(img,pimg);");
  Output->bottomline(Output->size());
}

void Processor::NormalThreshold() {
  if(img==NULL)   return;  
  SaveState();  
  pimg= cvCloneImage (img);  
  int typ;
  if(th.otsu)
    typ=th.type|CV_THRESH_OTSU;
  else
    typ=th.type;
  cvThreshold (img, pimg, th.thresh,th.maxVal,typ);



  proc->SetImage(pimg);
  After->redraw();

  char Buf[512];
  char *Types[]={"CV_THRESH_BINARY",
                 "CV_THRESH_BINARY_INV",
                 "CV_THRESH_TRUNC",
                 "CV_THRESH_TOZERO",
                 "CV_THRESH_TOZERO_INV"};

  Output->add("");
  Output->add("/* Normal Threshold of image */");
  Output->add("  if(pimg)");
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg= cvCloneImage (img); ");
  char otsuOn[]= " | CV_THRESH_OTSU";
  char otsuOff[]= " ";
  char *p=th.otsu ? otsuOn : otsuOff;
  sprintf(Buf,"cvThreshold (img, pimg, %.f, %.f, %s%s);", th.thresh,th.maxVal,Types[th.type],p);
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::AdaptiveThreshold() {
  if(img==NULL)   return;  


  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
      return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  pimg= cvCloneImage (img);  
  int typ=th.type;
  if(typ>=1)
    typ=CV_THRESH_BINARY;
  cvAdaptiveThreshold( img, pimg,th.maxVal,th.method,typ,th.block_size,th.param1);


  proc->SetImage(pimg);
  After->redraw();

  char Buf[512];
  char *Types[]={"CV_THRESH_BINARY",
                 "CV_THRESH_BINARY_INV"};
  char *Methods[]={"CV_THRESH_BINARY",
                   "CV_THRESH_BINARY_INV"};                

  Output->add("");
  Output->add("/* Adaptive Threshold of image */");
  Output->add("  if(pimg)");
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg= cvCloneImage (img); ");
  sprintf(Buf,"cvAdaptiveThreshold(img, pimg, %.f, %s , %s ,%d , %.f );",th.maxVal,Types[typ],Methods[th.method],th.block_size,th.param1);
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::Erode() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvErode (img,pimg, element,m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  WriteCodeMorph(0);
}

void Processor::Dilate() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvDilate (img,pimg, element,m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  WriteCodeMorph(1);
}

void Processor::Open() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_OPEN, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(2);
}

void Processor::Close() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_CLOSE, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(3);
}

void Processor::Grad() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_GRADIENT, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(4);
}

void Processor::TopHat() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_TOPHAT, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(5);
}

void Processor::BlackHat() {
  if(img==NULL)   return;  

  SaveState();  
  IplConvKernel *element;
  pimg= cvCloneImage (img);  
  timg= cvCloneImage (img);  
  element = cvCreateStructuringElementEx (m.cols,m.rows,m.anchor_x,m.anchor_y,m.shape, NULL);
  cvMorphologyEx (img, pimg, timg,element,CV_MOP_BLACKHAT, m.iterations);
  proc->SetImage(pimg);
  After->redraw();
  cvReleaseStructuringElement(&element );
  cvReleaseImage (&timg);
  WriteCodeMorph(6);
}

void Processor::WriteCodeMorph(int i) {
  char Buf[512];
  char *Shapes[]={"CV_SHAPE_RECT",
                  "CV_SHAPE_CROSS",
                  "CV_SHAPE_ELLIPSE"};  
                
  char *Operations[]= {"Erode",
	               "Dilate",
		       "Open",
		       "Close",
		       "Gradiant",
		       "Top Hat",		     
		       "Black Hat"};                  
  char *OpCodes[]= {"CV_MOP_OPEN",
	            "CV_MOP_CLOSE",
		    "CV_MOP_GRADIENT",
		    "CV_MOP_TOPHAT",
		    "CV_MOP_BLACKHAT"};                  		     


  Output->add("");
  sprintf(Buf,"/* Aplly %s Morphological Operation */" ,Operations[i]);

  Output->add(Buf);
  Output->add("{");
  Output->add("  IplConvKernel *element;"); 
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg= cvCloneImage (img); "); 
  sprintf(Buf,"  element = cvCreateStructuringElementEx (%d,%d,%d,%d,%s, NULL);",m.cols,m.rows,m.anchor_x,m.anchor_y,Shapes[m.shape]);
  Output->add(Buf);
  if(i>1){
    Output->add("  timg= cvCloneImage (img);"); 
    sprintf(Buf,"  cvMorphologyEx (img, pimg, timg,element,%s , %d);",OpCodes[i-2],m.iterations);
    Output->add(Buf);
    Output->add("  cvReleaseImage (&timg);");    
  }
  else if(i==0){
    sprintf(Buf,"  cvErode (img,pimg, element, %d);",m.iterations);
    Output->add(Buf);
  }else {
    sprintf(Buf,"  cvDilate (img,pimg, element, %d);",m.iterations);
    Output->add(Buf);
  }


  Output->add("  cvReleaseStructuringElement(&element );");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Sobel() {
  if(img==NULL)   return;  

  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
       return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);  
  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);  
  cvSobel (img, timg, ed.xOrder,ed.yOrder,Apertures[ed.aperture]);
  cvConvertScaleAbs (timg, pimg);
  proc->SetImage(pimg);
  After->redraw();

  cvReleaseImage (&timg);
// WriteCode

  char Buf[512];
  Output->add("");

  Output->add("/* Aplly Sobel Edge-Detection Operation */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);");  
  Output->add("  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);");  
  sprintf(Buf,"  cvSobel (img, timg, %d, %d, %d);",ed.xOrder,ed.yOrder,Apertures[ed.aperture]);
  Output->add(Buf);
  Output->add("  cvConvertScaleAbs (timg, pimg);");
  Output->add("  cvReleaseImage (&timg);");
  Output->bottomline(Output->size());
}

void Processor::Laplace() {
  if(img==NULL)   return;  

  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
       return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);  
  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);  
  cvLaplace (img, timg,Apertures[ed.aperture]);
  cvConvertScaleAbs (timg, pimg);
  proc->SetImage(pimg);
  After->redraw();

  cvReleaseImage (&timg);
// WriteCode

  char Buf[512];
  Output->add("");

  Output->add("/* Aplly Laplace Edge-Detection Operation */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  timg = cvCreateImage (cvGetSize (img), IPL_DEPTH_16S, 1);");  
  Output->add("  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);");  
  sprintf(Buf,"  cvLaplace (img, timg, %d);",Apertures[ed.aperture]);
  Output->add(Buf);
  Output->add("  cvConvertScaleAbs (timg, pimg);");
  Output->add("  cvReleaseImage (&timg);");
  Output->bottomline(Output->size());
}

void Processor::Canny() {
  if(img==NULL)   return;  

  if(img->nChannels==3){
    if(fl_choice("Source image must me single channel gray \n Do you want to convert it ?","No","Yes",NULL)==0)
      return; 
    RGBToGray();
    CopyTo1();
  }

  SaveState();  
  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);  
  // Dikkat min aperture size for canny 3
  cvCanny (img, pimg, ed.tmin,ed.tmax,Apertures[ed.aperture]<3 ? 3 : Apertures[ed.aperture]);  
  proc->SetImage(pimg);
  After->redraw();


  // WriteCode
  char Buf[512];
  Output->add("");

  Output->add("/* Aplly Canny Edge-Detection Operation */");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCreateImage (cvGetSize (img), IPL_DEPTH_8U, 1);");  
  sprintf(Buf,"  cvCanny (img, pimg, %d, %d, %d);",(int)ed.tmin,(int)ed.tmax,(Apertures[ed.aperture]<3 ? 3 : Apertures[ed.aperture]));
  Output->add(Buf);
  Output->bottomline(Output->size());
}

void Processor::Add() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }


  SaveState();  
  IplImage *mask=NULL;

  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  

  cvAdd(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");

  Output->add("/* Aplly Adding Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }

  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvAdd(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");


  Output->bottomline(Output->size());
}

void Processor::Sub() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }

  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  

  cvSub(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Subtraction Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvSub(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Mul() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;       
  }

  SaveState();  
  timg= cvCloneImage (img);  
  cvMul(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Multiplication Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvMul(img, pimg, timg, 1);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Div() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;       
  }


  SaveState();  
  timg= cvCloneImage (img);  
  cvDiv(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Division Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvDiv(img, pimg, timg, 1);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Max() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  

  if(!(((pimg->nChannels==1)&&(img->nChannels==1)&&img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have a single channel, the same data type and the same size ");
     return;        
  }


  SaveState();  
  timg= cvCloneImage (img);  
  cvMax(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Max Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvMax(img, pimg, timg);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Min() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!(((pimg->nChannels==1)&&(img->nChannels==1)&&img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have a single channel, the same data type and the same size ");
     return;       
  }


  SaveState();  
  timg= cvCloneImage (img);  
  cvMin(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Min Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvMin(img, pimg, timg);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::AbsDiff() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }

  SaveState();  
  timg= cvCloneImage (img);  
  cvAbsDiff(img, pimg, timg);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Absolute Difference  Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvAbsDiff(img, pimg, timg);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Compare(int op) {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!(((pimg->nChannels==1)&&(img->nChannels==1)&&img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have a single channel, the same data type and the same size ");
     return;        
  }

  SaveState();  

  timg= cvCloneImage (img);  
  cvCmp(img,pimg,timg,op);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  char Buf[512];
  char *OpCodes[]= {"CV_CMP_EQ",
	            "CV_CMP_GT",
		    "CV_CMP_GE",
		    "CV_CMP_LT",
		    "CV_CMP_LE",		    
		    "CV_CMP_NE"}; 

  Output->add("");
  Output->add("/* Aplly Compare Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  sprintf(Buf,"  cvCmp(img, pimg, timg, %s );",OpCodes[op]);
  Output->add(Buf);
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::And() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;     
  }


  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  
  cvAnd(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly And Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvAnd(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Or() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;        
  }


  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  
  cvOr(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Or Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvOr(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Xor() {
  if(img==NULL)   return;  
  if(pimg==NULL)  return;  
  if(!((img->nChannels==pimg->nChannels)&& (img->width==pimg->width) &&(img->height==pimg->height)) ){
     fl_alert("All the arrays must have the same type,and the same size ");
     return;       
  }


  SaveState();  
  IplImage *mask=NULL;
  if(mimg && (mimg->width==pimg->width) &&(mimg->height==pimg->height))  
    if(mimg->nChannels==1){
      if(fl_choice("Do you want to use Memory Image as an Mask ?","No","Yes",NULL))
        mask=mimg;
    }

  timg= cvCloneImage (img);  
  cvXor(img, pimg, timg, mask);

  proc->SetImage(timg);
  pimg=timg;
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Xor Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  IplImage *mask=NULL;");
  if(mimg){
    Output->add("  if(mimg->nChannels==1)");
    Output->add("    mask=mimg;");
  }
  Output->add("  if(timg)"); 
  Output->add("    cvReleaseImage(&timg);");
  Output->add("  timg = cvCloneImage (img);");  
  Output->add("  cvXor(img, pimg, timg, mask);");
  Output->add("  cvReleaseImage (&pimg);");
  Output->add("  pimg=timg;");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Not() {
  if(img==NULL)   return;  
  

  SaveState();  
  pimg= cvCloneImage (img);  
  cvNot(img, pimg);

  proc->SetImage(pimg);
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Aplly Logical Not Operation */");
  Output->add("/* Alert! there is no size and channel check */");
  Output->add("{");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCloneImage (img);");  
  Output->add("  cvNot(img, pimg);");
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Smooth() {
  char *TypeNames[]={
"CV_BLUR",
"CV_GAUSSIAN",
"CV_MEDIAN",
"CV_BILATERAL"
};
char Buf[512];

if(img==NULL)   return;  

  if(!sm.size1%2 || sm.size1 < 1 ){
    fl_alert("Size I : should be odd (1, 3, 5, ...)");
    return; 
  }
 
  if(sm.size2 && (sm.size2 < 0 || !sm.size2%2)){
    fl_alert("Size II : should be odd or zero");
    return; 
  }


  SaveState();  
  pimg= cvCloneImage (img);  
  cvSmooth (img, pimg, sm.type+1, sm.size1, sm.size2,sm.sigma1,sm.sigma2);

  proc->SetImage(pimg);
  After->redraw();

// WriteCode

  Output->add("");
  Output->add("/* Smoothes the image */");
  Output->add("{");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCloneImage (img);");  
  sprintf(Buf,"  cvSmooth (img, pimg, %s , %d , %d ,%.3f , %.3f );",TypeNames[sm.type], sm.size1, sm.size2,sm.sigma1,sm.sigma2);
  Output->add(Buf);
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::Filter2D(int row,int col,int X,int Y,float *data) {
  CvMat kernel = cvMat (row,col, CV_32F, data);


  SaveState();  
  pimg = cvCloneImage (img);

  // WriteCode
  char Buf[512];
  Output->add("");
  Output->add("/* Filter 2D  */");
  Output->add("{");
  sprintf(Buf,"  float data[%d];",row*col);
  Output->add(Buf);
  for(int i=0;i<row*col;i++){
    sprintf(Buf,"  data[%d]=%f;",i,data[i]);
    Output->add(Buf);    
  }
  // WriteCode  

  cvNormalize (&kernel, &kernel, 1.0, 0, CV_L1);
  cvFilter2D (img, pimg, &kernel, cvPoint (X, Y));
  proc->SetImage(pimg);
  After->redraw();
  

  

  // WriteCode
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  Output->add("  pimg = cvCloneImage (img);");  
  
  sprintf(Buf,"  CvMat kernel = cvMat (%d, %d, CV_32F, data);",row,col);
  Output->add(Buf);  
  Output->add("  cvNormalize (&kernel, &kernel, 1.0, 0, CV_L1);");
  
  sprintf(Buf,"  cvFilter2D (img, pimg, &kernel, cvPoint (%d,%d));",X,Y);
  Output->add(Buf);
  Output->add("}");
  Output->bottomline(Output->size());

  free(data);
}

void Processor::RGBFilter(int mode,int Rmin,int Rmax,int Gmin,int Gmax,int Bmin,int Bmax ) {
  SaveState();
  pimg=cvFilterRGB(img,Rmin,Rmax, Gmin, Gmax,Bmin,  Bmax, mode);
  proc->SetImage(pimg);
  After->redraw();
  
  // WriteCode

  char Buf[512];

  Output->add("");
  Output->add("/* RGB Color Filter */");
  Output->add("{");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  sprintf(Buf,"    pimg=cvFilterRGB(img,%d,%d, %d, %d, %d, %d, %d);",Rmin,Rmax, Gmin, Gmax,Bmin,  Bmax, mode);
  Output->add(Buf);
  Output->add("}");
  Output->bottomline(Output->size());
}

void Processor::HSFilter(int mode,int Hmin,int Hmax,int Smin,int Smax) {
  SaveState();
  pimg=cvFilterHS(img, Hmin, Hmax, Smin,Smax,mode);
  proc->SetImage(pimg);
  After->redraw();
  
  // WriteCode

  char Buf[512];

  Output->add("");
  Output->add("/* Hue Saturation Color Filter */");
  Output->add("{");
  Output->add("  if(pimg)"); 
  Output->add("    cvReleaseImage(&pimg);");
  sprintf(Buf,"    pimg=cvFilterHS(img, %d, %d, %d, %d, %d);",Hmin, Hmax, Smin,Smax,mode);
  Output->add(Buf);
  Output->add("}");
  Output->bottomline(Output->size());
}

void cb_Ok(Fl_Return_Button*o, void*w) {
  ((Fl_Window *)(o->parent()))->hide();
}

AboutDlg::AboutDlg() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(441, 284, "About");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(300, 240, 130, 30, "Ok");
      Ok->box(FL_GTK_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok);
    } // Fl_Return_Button* Ok
    { Info = new Fl_Browser(15, 14, 415, 212);
      Info->box(FL_EMBOSSED_FRAME);
      Info->color((Fl_Color)31);
      Info->textcolor(4);
    } // Fl_Browser* Info
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void AboutDlg::show() {
  Info->add("@l@c@C1cvPreProcessor");
  Info->add("  cvPreProcessor is a GUI tool for OpenCv ");
  Info->add("  Version : 0.90 ");

  Info->add(" ");
  Info->add("* Programmed by BlueKid");
  Info->add("  http://derindelimavi.blogspot.com/");
  Info->add(" ");
  Info->add("* Please Send me any suggestion, modification or bugs.");
  Info->add(" Don't hesitate to contact me for any question");
  Info->add(" I will be very grateful with your feedbacks.");
  Info->add(" bluekid70@gmail.com");

  window->show();
}

void AboutDlg::hide() {
  window->hide();
}

void MorphOptions::cb_Ok_i(Fl_Return_Button*, void*) {
  p->m.iterations=iterations->value();
p->m.cols=cols->value();
p->m.rows=rows->value();
p->m.anchor_x=ax->value();
p->m.anchor_y=ay->value();
p->m.shape=Shape->value();
hide();
}
void MorphOptions::cb_Ok(Fl_Return_Button* o, void* v) {
  ((MorphOptions*)(o->parent()->user_data()))->cb_Ok_i(o,v);
}

MorphOptions::MorphOptions() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(271, 336, "Morphological Operations");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(131, 296, 130, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok);
    } // Fl_Return_Button* Ok
    { iterations = new Fl_Spinner(150, 16, 40, 24, "Number of iterations:");
      iterations->maximum(10);
      iterations->value(1);
    } // Fl_Spinner* iterations
    { Fl_Group* o = new Fl_Group(10, 63, 245, 209, "Structuring Element");
      o->box(FL_ENGRAVED_FRAME);
      o->align(FL_ALIGN_TOP_LEFT);
      { Shape = new Fl_Choice(80, 80, 155, 24, "Shape :");
        Shape->box(FL_NO_BOX);
        Shape->down_box(FL_BORDER_BOX);
        Shape->add("Rectangular ");
        Shape->add("Cross-Shaped ");
        Shape->add("Elliptic");
      } // Fl_Choice* Shape
      { cols = new Fl_Spinner(195, 114, 40, 24, "Number of columns :");
        cols->maximum(99);
        cols->value(1);
      } // Fl_Spinner* cols
      { rows = new Fl_Spinner(195, 154, 40, 24, "Number of rows :");
        rows->maximum(99);
        rows->value(1);
      } // Fl_Spinner* rows
      { ax = new Fl_Spinner(195, 188, 40, 24, "Anchor X :");
        ax->maximum(49);
        ax->value(1);
      } // Fl_Spinner* ax
      { ay = new Fl_Spinner(195, 222, 40, 24, "Anchor Y :");
        ay->maximum(49);
        ay->value(1);
      } // Fl_Spinner* ay
      o->end();
    } // Fl_Group* o
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void MorphOptions::show() {
  iterations->value(p->m.iterations);
  cols->value(p->m.cols);
  rows->value(p->m.rows);
  ax->value(p->m.anchor_x);
  ay->value(p->m.anchor_y);
  Shape->value(p->m.shape);
  window->show();
}

void MorphOptions::hide() {
  window->hide();
}

void EdgeOptions::cb_Ok1_i(Fl_Return_Button*, void*) {
  p->ed.xOrder=xOrder->value();
p->ed.yOrder=yOrder->value();
p->ed.tmin=tmin->value();
p->ed.tmax=tmax->value();
p->ed.aperture=Aperture->value();

hide();
}
void EdgeOptions::cb_Ok1(Fl_Return_Button* o, void* v) {
  ((EdgeOptions*)(o->parent()->user_data()))->cb_Ok1_i(o,v);
}

void EdgeOptions::cb_tmin_i(Fl_Value_Slider*, void*) {
  tmax->minimum(tmin->value()+1);
tmax->redraw();
}
void EdgeOptions::cb_tmin(Fl_Value_Slider* o, void* v) {
  ((EdgeOptions*)(o->parent()->parent()->user_data()))->cb_tmin_i(o,v);
}

void EdgeOptions::cb_tmax_i(Fl_Value_Slider*, void*) {
  tmin->maximum(tmax->value()-1);
tmin->redraw();
}
void EdgeOptions::cb_tmax(Fl_Value_Slider* o, void* v) {
  ((EdgeOptions*)(o->parent()->parent()->user_data()))->cb_tmax_i(o,v);
}

EdgeOptions::EdgeOptions() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(271, 336, "Edge Detection ");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(131, 296, 130, 30, "Ok");
      Ok->box(FL_GTK_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok1);
    } // Fl_Return_Button* Ok
    { Aperture = new Fl_Choice(111, 16, 155, 24, "Aperture  Size :");
      Aperture->down_box(FL_BORDER_BOX);
      Aperture->add("CV_SCHARR");
      Aperture->add("1x3 or 3x1");
      Aperture->add("3x3");Aperture->add("5x5");
      Aperture->add("7x7");Aperture->value(1);
    } // Fl_Choice* Aperture
    { Fl_Group* o = new Fl_Group(15, 66, 246, 60, "Sobel");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { xOrder = new Fl_Round_Button(29, 75, 81, 15, "X Order");
        xOrder->type(102);
        xOrder->down_box(FL_ROUND_DOWN_BOX);
        xOrder->value(1);
        xOrder->align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE);
      } // Fl_Round_Button* xOrder
      { yOrder = new Fl_Round_Button(31, 100, 79, 16, "YOrder");
        yOrder->type(102);
        yOrder->down_box(FL_ROUND_DOWN_BOX);
        yOrder->align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE);
      } // Fl_Round_Button* yOrder
      o->end();
    } // Fl_Group* o
    { Fl_Group* o = new Fl_Group(15, 146, 246, 129, "Canny");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { tmin = new Fl_Value_Slider(25, 175, 226, 20, "Threshold Min");
        tmin->type(5);
        tmin->box(FL_PLASTIC_DOWN_BOX);
        tmin->color((Fl_Color)12);
        tmin->selection_color((Fl_Color)1);
        tmin->maximum(255);
        tmin->step(1);
        tmin->textsize(14);
        tmin->callback((Fl_Callback*)cb_tmin);
        tmin->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* tmin
      { tmax = new Fl_Value_Slider(25, 230, 226, 20, "Threshold Max");
        tmax->type(5);
        tmax->box(FL_PLASTIC_DOWN_BOX);
        tmax->color((Fl_Color)12);
        tmax->selection_color((Fl_Color)1);
        tmax->maximum(255);
        tmax->step(1);
        tmax->value(255);
        tmax->textsize(14);
        tmax->callback((Fl_Callback*)cb_tmax);
        tmax->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* tmax
      o->end();
    } // Fl_Group* o
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void EdgeOptions::show() {
  xOrder->value(p->ed.xOrder);
  yOrder->value(p->ed.yOrder);
  tmin->value(p->ed.tmin);
  tmax->value(p->ed.tmax);
  Aperture->value(p->ed.aperture);

  window->show();
}

void EdgeOptions::hide() {
  window->hide();
}

void ThresholdOptions::cb_Ok2_i(Fl_Return_Button*, void*) {
  Update();
hide();
}
void ThresholdOptions::cb_Ok2(Fl_Return_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->user_data()))->cb_Ok2_i(o,v);
}

void ThresholdOptions::cb_Otsu_i(Fl_Check_Button*, void*) {
  if(Otsu->value()) 
  thresh->deactivate();
else
  thresh->activate();
}
void ThresholdOptions::cb_Otsu(Fl_Check_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->parent()->user_data()))->cb_Otsu_i(o,v);
}

void ThresholdOptions::cb_Apply_i(Fl_Button*, void*) {
  Update();
p->NormalThreshold();
}
void ThresholdOptions::cb_Apply(Fl_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->user_data()))->cb_Apply_i(o,v);
}

void ThresholdOptions::cb_Apply1_i(Fl_Button*, void*) {
  Update();
p->AdaptiveThreshold();
}
void ThresholdOptions::cb_Apply1(Fl_Button* o, void* v) {
  ((ThresholdOptions*)(o->parent()->user_data()))->cb_Apply1_i(o,v);
}

ThresholdOptions::ThresholdOptions() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(416, 448, "Threshold Options");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(306, 405, 99, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok2);
    } // Fl_Return_Button* Ok
    { Fl_Group* o = new Fl_Group(15, 116, 390, 112, "Normal ");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { thresh = new Fl_Value_Slider(25, 145, 370, 20, "Threshold Value");
        thresh->type(5);
        thresh->box(FL_PLASTIC_DOWN_BOX);
        thresh->color((Fl_Color)12);
        thresh->selection_color((Fl_Color)1);
        thresh->maximum(255);
        thresh->step(1);
        thresh->value(128);
        thresh->textsize(14);
        thresh->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* thresh
      { Otsu = new Fl_Check_Button(30, 190, 64, 20, "use Otsu method");
        Otsu->down_box(FL_DOWN_BOX);
        Otsu->callback((Fl_Callback*)cb_Otsu);
      } // Fl_Check_Button* Otsu
      o->end();
    } // Fl_Group* o
    { max = new Fl_Value_Slider(20, 30, 380, 20, "Max Value");
      max->type(5);
      max->box(FL_PLASTIC_DOWN_BOX);
      max->color((Fl_Color)12);
      max->selection_color((Fl_Color)1);
      max->maximum(255);
      max->step(1);
      max->value(255);
      max->textsize(14);
      max->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* max
    { Type = new Fl_Choice(130, 66, 245, 24, "Threshold Type :");
      Type->down_box(FL_BORDER_BOX);
      Type->add("CV_THRESH_BINARY");
      Type->add("CV_THRESH_BINARY_INV");
      Type->add("CV_THRESH_TRUNC");Type->add("CV_THRESH_TOZERO");
      Type->add("CV_THRESH_TOZERO_INV");Type->value(0);
    } // Fl_Choice* Type
    { Fl_Group* o = new Fl_Group(20, 254, 385, 133, "Adaptive Threshold");
      o->box(FL_EMBOSSED_FRAME);
      o->labelfont(2);
      o->labelcolor((Fl_Color)4);
      o->align(FL_ALIGN_TOP_LEFT);
      { Method = new Fl_Choice(89, 260, 306, 21, "Method :");
        Method->down_box(FL_BORDER_BOX);
        Method->add("CV_ADAPTIVE_THRESH_MEAN_C");
        Method->add("CV_ADAPTIVE_THRESH_GAUSSIAN_C");
        Method->value(0);
      } // Fl_Choice* Method
      { BlockSize = new Fl_Spinner(110, 339, 40, 24, "Block Size :");
        BlockSize->minimum(3);
        BlockSize->maximum(33);
        BlockSize->step(2);
        BlockSize->value(3);
      } // Fl_Spinner* BlockSize
      { Param1 = new Fl_Value_Input(155, 296, 40, 24, "Method-parameter:");
        Param1->minimum(-50);
        Param1->maximum(50);
        Param1->value(5);
      } // Fl_Value_Input* Param1
      o->end();
    } // Fl_Group* o
    { Fl_Button* o = new Fl_Button(20, 405, 105, 30, "Apply Normal ");
      o->box(FL_GTK_UP_BOX);
      o->color(FL_SELECTION_COLOR);
      o->callback((Fl_Callback*)cb_Apply);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(135, 405, 105, 30, "Apply Adaptive");
      o->box(FL_GTK_UP_BOX);
      o->color(FL_SELECTION_COLOR);
      o->callback((Fl_Callback*)cb_Apply1);
    } // Fl_Button* o
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void ThresholdOptions::show() {
  thresh->value(p->th.thresh);
  max->value(p->th.maxVal);
  Type->value(p->th.type);
  Method->value(p->th.method);
  BlockSize->value(p->th.block_size);
  Param1->value(p->th.param1);
  Otsu->value(p->th.otsu);
  if(Otsu->value()) 
    thresh->deactivate();
  else
    thresh->activate();


  window->show();
}

void ThresholdOptions::hide() {
  window->hide();
}

void ThresholdOptions::Update() {
  p->th.thresh=thresh->value();
  p->th.maxVal=max->value();
  p->th.type=Type->value();
  p->th.method=Method->value();
  p->th.block_size=BlockSize->value();
  p->th.param1=Param1->value();
  p->th.otsu=Otsu->value();
}

void ReSizeForm::cb_Ok3_i(Fl_Return_Button*, void*) {
  p->r.method=Interpolation->value();
  p->r.ratio=ratio->value();
  p->r.aspect=aspect->value();
  p->r.rwidth=rwidth->value();
  p->r.rheight=rheight->value();  
  p->ReSize();
  hide();
}
void ReSizeForm::cb_Ok3(Fl_Return_Button* o, void* v) {
  ((ReSizeForm*)(o->parent()->user_data()))->cb_Ok3_i(o,v);
}

void ReSizeForm::cb_aspect_i(Fl_Check_Button*, void*) {
  if(aspect->value())
  ratio->activate();
else
  ratio->deactivate();
}
void ReSizeForm::cb_aspect(Fl_Check_Button* o, void* v) {
  ((ReSizeForm*)(o->parent()->user_data()))->cb_aspect_i(o,v);
}

void ReSizeForm::cb_ratio_i(Fl_Value_Slider*, void*) {
  rwidth->value(int(oldw->value()*ratio->value()*0.01));
rheight->value(int(oldh->value()*ratio->value()*0.01));
}
void ReSizeForm::cb_ratio(Fl_Value_Slider* o, void* v) {
  ((ReSizeForm*)(o->parent()->user_data()))->cb_ratio_i(o,v);
}

ReSizeForm::ReSizeForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(359, 336, "ReSize Image");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(215, 296, 130, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok3);
    } // Fl_Return_Button* Ok
    { Interpolation = new Fl_Choice(115, 21, 195, 24, "Interpolation :");
      Interpolation->box(FL_NO_BOX);
      Interpolation->down_box(FL_BORDER_BOX);
      Interpolation->add("Nearest-Neigbor");
      Interpolation->add("Bilinear");
      Interpolation->add("Pixel Area");
      Interpolation->add("Bicubic");Interpolation->value(1);
    } // Fl_Choice* Interpolation
    { aspect = new Fl_Check_Button(30, 134, 210, 26, "Preserve Aspect Ratio");
      aspect->down_box(FL_DOWN_BOX);
      aspect->value(1);
      aspect->callback((Fl_Callback*)cb_aspect);
    } // Fl_Check_Button* aspect
    { oldw = new Fl_Value_Output(120, 66, 120, 24, "Image Width:");
      oldw->value(10);
    } // Fl_Value_Output* oldw
    { oldh = new Fl_Value_Output(120, 100, 120, 24, "Image Height:");
      oldh->value(20);
    } // Fl_Value_Output* oldh
    { ratio = new Fl_Value_Slider(89, 170, 251, 20, "Ratio % :");
      ratio->type(1);
      ratio->color((Fl_Color)23);
      ratio->minimum(10);
      ratio->maximum(500);
      ratio->step(10);
      ratio->value(100);
      ratio->textsize(14);
      ratio->callback((Fl_Callback*)cb_ratio);
      ratio->align(FL_ALIGN_LEFT);
    } // Fl_Value_Slider* ratio
    { rwidth = new Fl_Value_Input(120, 206, 147, 24, "New Width:");
    } // Fl_Value_Input* rwidth
    { rheight = new Fl_Value_Input(120, 246, 147, 24, "New Heigth:");
    } // Fl_Value_Input* rheight
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void ReSizeForm::show() {
  oldw->value(img->width);
  oldh->value(img->height);
  Interpolation->value(p->r.method);
  ratio->value(p->r.ratio);
  aspect->value(p->r.aspect);

  if(aspect->value()){
    ratio->activate();
    rwidth->value(int(oldw->value()*ratio->value()*0.01));
    rheight->value(int(oldh->value()*ratio->value()*0.01));  
  }
  else{
    ratio->deactivate();
    rwidth->value(img->width);
    rheight->value(img->height);  
  }
  
  window->show();
}

void ReSizeForm::hide() {
  window->hide();
}

void HistForm::cb_Ok4_i(Fl_Return_Button*, void*) {
  hide();
}
void HistForm::cb_Ok4(Fl_Return_Button* o, void* v) {
  ((HistForm*)(o->parent()->user_data()))->cb_Ok4_i(o,v);
}

void HistForm::cb_Type_i(Fl_Spinner*, void*) {
  Chart->type(Type->value());
Chart->redraw();
}
void HistForm::cb_Type(Fl_Spinner* o, void* v) {
  ((HistForm*)(o->parent()->user_data()))->cb_Type_i(o,v);
}

void HistForm::cb_Ch_i(Fl_Choice*, void*) {
  Draw();
}
void HistForm::cb_Ch(Fl_Choice* o, void* v) {
  ((HistForm*)(o->parent()->user_data()))->cb_Ch_i(o,v);
}

HistForm::HistForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(811, 535, "Color Histogram");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(671, 495, 130, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok4);
    } // Fl_Return_Button* Ok
    { Chart = new Fl_Chart(10, 44, 791, 362);
      Chart->box(FL_GTK_DOWN_BOX);
      Chart->color((Fl_Color)18);
      Chart->selection_color(FL_BACKGROUND_COLOR);
      Chart->labeltype(FL_NORMAL_LABEL);
      Chart->labelfont(0);
      Chart->labelsize(14);
      Chart->labelcolor(FL_FOREGROUND_COLOR);
      Chart->align(FL_ALIGN_CENTER);
      Chart->when(FL_WHEN_RELEASE);
    } // Fl_Chart* Chart
    { Type = new Fl_Spinner(100, 10, 40, 24, "Chart Type  :");
      Type->minimum(0);
      Type->maximum(4);
      Type->value(3);
      Type->callback((Fl_Callback*)cb_Type);
    } // Fl_Spinner* Type
    { Ch = new Fl_Choice(260, 10, 190, 24, "Channel :");
      Ch->down_box(FL_BORDER_BOX);
      Ch->callback((Fl_Callback*)cb_Ch);
      Ch->add("Red"); Ch->add("Green");Ch->add("Blue");
      Ch->add("Hue");Ch->add("Saturation");
      Ch->value(0);
    } // Fl_Choice* Ch
    { Non_Zero = new Fl_Value_Output(121, 427, 114, 24, "Count Non-zero :");
    } // Fl_Value_Output* Non_Zero
    { Sum = new Fl_Value_Output(120, 461, 115, 24, "Sum :");
    } // Fl_Value_Output* Sum
    { Avg = new Fl_Value_Output(120, 495, 115, 24, "Avarage :");
    } // Fl_Value_Output* Avg
    { StdDev = new Fl_Value_Output(441, 427, 114, 24, "Standart Deviation:");
    } // Fl_Value_Output* StdDev
    { Min = new Fl_Value_Output(440, 461, 115, 24, "Min :");
    } // Fl_Value_Output* Min
    { Max = new Fl_Value_Output(440, 495, 115, 24, "Max :");
    } // Fl_Value_Output* Max
    { Width = new Fl_Value_Output(680, 427, 114, 24, "Image Width :");
    } // Fl_Value_Output* Width
    { Height = new Fl_Value_Output(680, 461, 114, 24, "Image Height :");
    } // Fl_Value_Output* Height
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void HistForm::show() {
  Chart->autosize(1);
Calculate();
Draw();
if(img->nChannels==1)
  Ch->hide();

window->show();
}

void HistForm::hide() {
  int k=1;
  if(img->nChannels==3) 
    k=5;
  for(int i=0;i< k;i++){
    cvReleaseImage (&himg[i]);  
    cvReleaseHist (&hist[i]);  
  }  
//  fl_alert("Images Released");
  window->hide();
}

void HistForm::Draw() {
  int np=256;
  int kRed[]  ={1,0,0,0,1,1};
  int kGreen[]={0,1,0,1,1,1};
  int kBlue[]={0,0,1,1,0,1};
  int j=Ch->value();
  int ci;

  if(img->nChannels==1)
    ci=5;
  else
    ci=j;

  Chart->clear();
  Chart->type(Type->value());
  if(j==3)
    np=181;
  
  char buf[4];
  for(int i=0;i<np;i++){
  
    if(i%10==0){
       sprintf(buf,"%d",i);
    }
    else
      buf[0]=0;
    Chart->add(cvGetReal1D (hist[j]->bins, i),buf,fl_rgb_color(kRed[ci]*i,kGreen[ci]*i,kBlue[ci]*i));
  }
  
  Non_Zero->value(non_zeros[j]);
  Sum->value(sums[j]);  
  Avg->value(avgs[j]);      
  StdDev->value(std_devs[j]);
  Min->value(mins[j]);  
  Max->value(maxs[j]);
}

void HistForm::Calculate() {
  float crange[] = { 0, 255 };  
  float *ranges[] = { crange };
  int hist_size = 256;
  int k=1;
  if(img->nChannels==3) 
    k=5;
  
  for(int i=0;i< k;i++)
    himg[i] = cvCreateImage (cvSize (img->width, img->height), img->depth, 1);


  if(img->nChannels==1){
    cvCopy (img, himg[0], NULL);  

  }
  else{
    cvSplit (img, himg[0], himg[1], himg[2], 0);  
    timg = cvCreateImage( cvGetSize(img), 8, 3 );
    cvCvtColor( img, timg, CV_RGB2HSV );
    cvSplit (timg, himg[3], 0, 0, 0);
    cvSplit (timg, 0, himg[4], 0, 0);
    cvReleaseImage (&timg);          
  }
  for(int i=0;i<k;i++){

     hist[i] = cvCreateHist (1, &hist_size, CV_HIST_ARRAY, ranges, 1);
     cvCalcHist (&himg[i], hist[i], 0, NULL);

     CvScalar avg, sd;
     non_zeros[i]=cvCountNonZero(himg[i]);
     cvAvgSdv(himg[i], &avg, &sd);
     avgs[i]=avg.val[0];
     std_devs[i]=sd.val[0];
     cvMinMaxLoc(himg[i],&mins[i],&maxs[i]);       
     
  }
  
Height->value(img->height);
Width->value(img->width);
}

void SmoothForm::cb_Ok5_i(Fl_Return_Button*, void*) {
  save();
  hide();
}
void SmoothForm::cb_Ok5(Fl_Return_Button* o, void* v) {
  ((SmoothForm*)(o->parent()->user_data()))->cb_Ok5_i(o,v);
}

void SmoothForm::cb_Apply2_i(Fl_Button*, void*) {
  save();
  p->Smooth();
}
void SmoothForm::cb_Apply2(Fl_Button* o, void* v) {
  ((SmoothForm*)(o->parent()->user_data()))->cb_Apply2_i(o,v);
}

SmoothForm::SmoothForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(312, 192, "Smoothes the image");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(190, 145, 115, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok5);
    } // Fl_Return_Button* Ok
    { Type = new Fl_Choice(115, 21, 185, 24, "Smooth Type :");
      Type->box(FL_NO_BOX);
      Type->down_box(FL_BORDER_BOX);
      Type->add("CV_BLUR");Type->add("CV_GAUSSIAN");
      Type->add("CV_MEDIAN");Type->add("CV_BILATERAL");
      Type->value(1);
    } // Fl_Choice* Type
    { size1 = new Fl_Value_Input(80, 62, 50, 23, "Size I     :");
      size1->value(3);
    } // Fl_Value_Input* size1
    { size2 = new Fl_Value_Input(80, 95, 50, 24, "Size II    :");
    } // Fl_Value_Input* size2
    { sigma1 = new Fl_Value_Input(250, 62, 50, 23, "Sigma I :");
    } // Fl_Value_Input* sigma1
    { sigma2 = new Fl_Value_Input(250, 95, 50, 24, "Sigma II :");
    } // Fl_Value_Input* sigma2
    { Fl_Button* o = new Fl_Button(20, 145, 120, 30, "Apply");
      o->box(FL_GTK_UP_BOX);
      o->color(FL_SELECTION_COLOR);
      o->callback((Fl_Callback*)cb_Apply2);
    } // Fl_Button* o
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void SmoothForm::show() {
  Type->value(p->sm.type);
size1->value(p->sm.size1);
size2->value(p->sm.size2);
sigma1->value(p->sm.sigma1);
sigma2->value(p->sm.sigma2);
window->show();
}

void SmoothForm::hide() {
  window->hide();
}

void SmoothForm::save() {
  p->sm.type=Type->value();
  p->sm.size1=size1->value();
  p->sm.size2=size2->value();
  p->sm.sigma1=sigma1->value();
  p->sm.sigma2=sigma2->value();
}

void RotateForm::cb_Ok6_i(Fl_Return_Button*, void*) {
  hide();
}
void RotateForm::cb_Ok6(Fl_Return_Button* o, void* v) {
  ((RotateForm*)(o->parent()->user_data()))->cb_Ok6_i(o,v);
}

void RotateForm::cb_Apply3_i(Fl_Button*, void*) {
  p->Rotate(Angle->value());
}
void RotateForm::cb_Apply3(Fl_Button* o, void* v) {
  ((RotateForm*)(o->parent()->user_data()))->cb_Apply3_i(o,v);
}

void RotateForm::cb_dl_i(Fl_Dial*, void*) {
  Angle->value(dl->value());
}
void RotateForm::cb_dl(Fl_Dial* o, void* v) {
  ((RotateForm*)(o->parent()->user_data()))->cb_dl_i(o,v);
}

RotateForm::RotateForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(400, 123, "Rotates the image");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(272, 80, 120, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok6);
    } // Fl_Return_Button* Ok
    { Fl_Button* o = new Fl_Button(272, 33, 120, 30, "Apply");
      o->box(FL_GTK_UP_BOX);
      o->color(FL_SELECTION_COLOR);
      o->callback((Fl_Callback*)cb_Apply3);
    } // Fl_Button* o
    { dl = new Fl_Dial(15, 16, 90, 87);
      dl->type(1);
      dl->box(FL_GTK_ROUND_UP_BOX);
      dl->color((Fl_Color)179);
      dl->minimum(-130);
      dl->maximum(130);
      dl->step(1);
      dl->callback((Fl_Callback*)cb_dl);
    } // Fl_Dial* dl
    { Angle = new Fl_Value_Output(130, 44, 99, 24, "Rotate Angle");
      Angle->align(FL_ALIGN_TOP);
    } // Fl_Value_Output* Angle
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void RotateForm::show() {
  window->show();
}

void RotateForm::hide() {
  window->hide();
}

void RGBFilterForm::cb_Ok7_i(Fl_Return_Button*, void*) {
  hide();
}
void RGBFilterForm::cb_Ok7(Fl_Return_Button* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Ok7_i(o,v);
}

void RGBFilterForm::cb_Apply4_i(Fl_Button*, void*) {
  if(FirstTime==false)
  p->Undo(false);
else
  FirstTime=false;  
p->RGBFilter(Mode->value(),Rmin->value(),Rmax->value(),Gmin->value(),Gmax->value(),Bmin->value(),Bmax->value());
}
void RGBFilterForm::cb_Apply4(Fl_Button* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Apply4_i(o,v);
}

void RGBFilterForm::cb_Rmin_i(Fl_Value_Slider*, void*) {
  Rmin->color(fl_rgb_color(Rmin->value(),0,0));
Rmax->minimum(Rmin->value());
changecolor();
}
void RGBFilterForm::cb_Rmin(Fl_Value_Slider* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Rmin_i(o,v);
}

void RGBFilterForm::cb_Rmax_i(Fl_Value_Slider*, void*) {
  Rmax->color(fl_rgb_color(Rmax->value(),0,0));
Rmin->maximum(Rmax->value());
changecolor();
}
void RGBFilterForm::cb_Rmax(Fl_Value_Slider* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Rmax_i(o,v);
}

void RGBFilterForm::cb_Gmin_i(Fl_Value_Slider*, void*) {
  Gmin->color(fl_rgb_color(0,Gmin->value(),0));
Gmax->minimum(Gmin->value());
changecolor();
}
void RGBFilterForm::cb_Gmin(Fl_Value_Slider* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Gmin_i(o,v);
}

void RGBFilterForm::cb_Gmax_i(Fl_Value_Slider*, void*) {
  Gmax->color(fl_rgb_color(0,Gmax->value(),0));
Gmin->maximum(Gmax->value());
changecolor();
}
void RGBFilterForm::cb_Gmax(Fl_Value_Slider* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Gmax_i(o,v);
}

void RGBFilterForm::cb_Bmin_i(Fl_Value_Slider*, void*) {
  Bmin->color(fl_rgb_color(0,0,Bmin->value()));
Bmax->minimum(Bmin->value());
changecolor();
}
void RGBFilterForm::cb_Bmin(Fl_Value_Slider* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Bmin_i(o,v);
}

void RGBFilterForm::cb_Bmax_i(Fl_Value_Slider*, void*) {
  Bmax->color(fl_rgb_color(0,0,Bmax->value()));
Bmin->maximum(Bmax->value());
changecolor();
}
void RGBFilterForm::cb_Bmax(Fl_Value_Slider* o, void* v) {
  ((RGBFilterForm*)(o->parent()->user_data()))->cb_Bmax_i(o,v);
}

RGBFilterForm::RGBFilterForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(545, 269, "RGB Filter");
    window->box(FL_UP_BOX);
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(405, 215, 120, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok7);
    } // Fl_Return_Button* Ok
    { Fl_Button* o = new Fl_Button(250, 215, 120, 30, "Apply");
      o->box(FL_GTK_UP_BOX);
      o->color(FL_SELECTION_COLOR);
      o->callback((Fl_Callback*)cb_Apply4);
    } // Fl_Button* o
    { Chart = new Fl_Group(10, 14, 185, 181);
      Chart->box(FL_UP_FRAME);
      { C5 = new Fl_Box(21, 24, 40, 40);
        C5->box(FL_DOWN_BOX);
      } // Fl_Box* C5
      { Cm = new Fl_Box(63, 68, 74, 74);
        Cm->box(FL_DIAMOND_DOWN_BOX);
      } // Fl_Box* Cm
      { C7 = new Fl_Box(80, 25, 40, 40);
        C7->box(FL_DOWN_BOX);
      } // Fl_Box* C7
      { C8 = new Fl_Box(140, 25, 40, 40);
        C8->box(FL_DOWN_BOX);
      } // Fl_Box* C8
      { C3 = new Fl_Box(20, 85, 40, 40);
        C3->box(FL_DOWN_BOX);
      } // Fl_Box* C3
      { C1 = new Fl_Box(20, 145, 40, 40);
        C1->box(FL_DOWN_BOX);
      } // Fl_Box* C1
      { C2 = new Fl_Box(80, 145, 40, 40);
        C2->box(FL_DOWN_BOX);
      } // Fl_Box* C2
      { C6 = new Fl_Box(140, 85, 40, 40);
        C6->box(FL_DOWN_BOX);
      } // Fl_Box* C6
      { C4 = new Fl_Box(140, 145, 40, 40);
        C4->box(FL_DOWN_BOX);
      } // Fl_Box* C4
      Chart->end();
    } // Fl_Group* Chart
    { Rmin = new Fl_Value_Slider(220, 31, 30, 159, "Rmin");
      Rmin->type(4);
      Rmin->box(FL_GTK_DOWN_BOX);
      Rmin->color((Fl_Color)1);
      Rmin->labelfont(1);
      Rmin->labelcolor((Fl_Color)1);
      Rmin->maximum(254);
      Rmin->step(1);
      Rmin->textsize(14);
      Rmin->textcolor(7);
      Rmin->callback((Fl_Callback*)cb_Rmin);
      Rmin->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* Rmin
    { Rmax = new Fl_Value_Slider(260, 31, 30, 159, "Rmax");
      Rmax->type(4);
      Rmax->box(FL_GTK_DOWN_BOX);
      Rmax->color((Fl_Color)1);
      Rmax->labelfont(1);
      Rmax->labelcolor((Fl_Color)1);
      Rmax->minimum(1);
      Rmax->maximum(255);
      Rmax->step(1);
      Rmax->value(255);
      Rmax->textsize(14);
      Rmax->textcolor(7);
      Rmax->callback((Fl_Callback*)cb_Rmax);
      Rmax->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* Rmax
    { Gmin = new Fl_Value_Slider(335, 31, 30, 159, "Gmin");
      Gmin->type(4);
      Gmin->box(FL_GTK_DOWN_BOX);
      Gmin->color((Fl_Color)2);
      Gmin->labelfont(1);
      Gmin->labelcolor((Fl_Color)2);
      Gmin->maximum(254);
      Gmin->step(1);
      Gmin->textsize(14);
      Gmin->textcolor(7);
      Gmin->callback((Fl_Callback*)cb_Gmin);
      Gmin->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* Gmin
    { Gmax = new Fl_Value_Slider(380, 31, 30, 159, "Gmax");
      Gmax->type(4);
      Gmax->box(FL_GTK_DOWN_BOX);
      Gmax->color((Fl_Color)2);
      Gmax->labelfont(1);
      Gmax->labelcolor((Fl_Color)2);
      Gmax->minimum(1);
      Gmax->maximum(255);
      Gmax->step(1);
      Gmax->value(255);
      Gmax->textsize(14);
      Gmax->textcolor(7);
      Gmax->callback((Fl_Callback*)cb_Gmax);
      Gmax->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* Gmax
    { Bmin = new Fl_Value_Slider(450, 31, 30, 159, "Bmin");
      Bmin->type(4);
      Bmin->box(FL_GTK_DOWN_BOX);
      Bmin->color((Fl_Color)4);
      Bmin->labelfont(1);
      Bmin->labelcolor((Fl_Color)4);
      Bmin->maximum(254);
      Bmin->step(1);
      Bmin->textsize(14);
      Bmin->textcolor(7);
      Bmin->callback((Fl_Callback*)cb_Bmin);
      Bmin->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* Bmin
    { Bmax = new Fl_Value_Slider(495, 31, 30, 159, "Bmax");
      Bmax->type(4);
      Bmax->box(FL_GTK_DOWN_BOX);
      Bmax->color((Fl_Color)4);
      Bmax->labelfont(1);
      Bmax->labelcolor((Fl_Color)4);
      Bmax->minimum(1);
      Bmax->maximum(255);
      Bmax->step(1);
      Bmax->value(255);
      Bmax->textsize(14);
      Bmax->textcolor(7);
      Bmax->callback((Fl_Callback*)cb_Bmax);
      Bmax->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Slider* Bmax
    { Mode = new Fl_Check_Button(25, 220, 110, 15, "Color Mask");
      Mode->down_box(FL_DOWN_BOX);
      Mode->value(1);
    } // Fl_Check_Button* Mode
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void RGBFilterForm::show() {
  changecolor();
Rmin->color(fl_rgb_color(Rmin->value(),0,0));
Gmin->color(fl_rgb_color(0,Gmin->value(),0));
Bmin->color(fl_rgb_color(0,0,Bmin->value()));
FirstTime=true;
window->show();
}

void RGBFilterForm::hide() {
  window->hide();
}

void RGBFilterForm::changecolor() {
  C1->color(fl_rgb_color(Rmin->value(),Gmin->value(), Bmin->value()));
C2->color(fl_rgb_color(Rmax->value(),Gmin->value(), Bmin->value()));
C3->color(fl_rgb_color(Rmin->value(),Gmax->value(), Bmin->value()));
C4->color(fl_rgb_color(Rmin->value(),Gmin->value(), Bmax->value()));

C5->color(fl_rgb_color(Rmax->value(),Gmax->value(), Bmin->value()));
C6->color(fl_rgb_color(Rmax->value(),Gmin->value(), Bmax->value()));
C7->color(fl_rgb_color(Rmin->value(),Gmax->value(), Bmax->value()));
C8->color(fl_rgb_color(Rmax->value(),Gmax->value(), Bmax->value()));
unsigned char rm, gm,bm;

rm=(Rmax->value()+Rmin->value())/2;
gm=(Gmax->value()+Gmin->value())/2;
bm=(Bmax->value()+Bmin->value())/2;

Cm->color(fl_rgb_color(rm,gm,bm));

Chart->redraw();
}

void HSFilterForm::cb_Ok8_i(Fl_Return_Button*, void*) {
  hide();
}
void HSFilterForm::cb_Ok8(Fl_Return_Button* o, void* v) {
  ((HSFilterForm*)(o->parent()->user_data()))->cb_Ok8_i(o,v);
}

void HSFilterForm::cb_Apply5_i(Fl_Button*, void*) {
  if(FirstTime==false)
  p->Undo(false);
else
  FirstTime=false;  
p->HSFilter(Mode->value(),Hmin->value(),Hmax->value(),Smin->value(),Smax->value());
}
void HSFilterForm::cb_Apply5(Fl_Button* o, void* v) {
  ((HSFilterForm*)(o->parent()->user_data()))->cb_Apply5_i(o,v);
}

void HSFilterForm::cb_Hmin_i(Fl_Value_Slider*, void*) {
  // Rmin->color(fl_rgb_color(Rmin->value(),0,0));
Hmax->minimum(Hmin->value());
changecolor();
Hmin->redraw();
}
void HSFilterForm::cb_Hmin(Fl_Value_Slider* o, void* v) {
  ((HSFilterForm*)(o->parent()->parent()->user_data()))->cb_Hmin_i(o,v);
}

void HSFilterForm::cb_Hmax_i(Fl_Value_Slider*, void*) {
  //Rmax->color(fl_rgb_color(Rmax->value(),0,0));
Hmin->maximum(Hmax->value());
changecolor();
}
void HSFilterForm::cb_Hmax(Fl_Value_Slider* o, void* v) {
  ((HSFilterForm*)(o->parent()->parent()->user_data()))->cb_Hmax_i(o,v);
}

void HSFilterForm::cb_Smin_i(Fl_Value_Slider*, void*) {
  // Smin->color(fl_rgb_color(0,Gmin->value(),0));
Smax->minimum(Smin->value());
changecolor();
}
void HSFilterForm::cb_Smin(Fl_Value_Slider* o, void* v) {
  ((HSFilterForm*)(o->parent()->parent()->user_data()))->cb_Smin_i(o,v);
}

void HSFilterForm::cb_Smax_i(Fl_Value_Slider*, void*) {
  Smin->maximum(Smax->value());
changecolor();
}
void HSFilterForm::cb_Smax(Fl_Value_Slider* o, void* v) {
  ((HSFilterForm*)(o->parent()->parent()->user_data()))->cb_Smax_i(o,v);
}

HSFilterForm::HSFilterForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(451, 269, "Hue - Saturation  Filter");
    window->box(FL_UP_BOX);
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(310, 210, 120, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok8);
    } // Fl_Return_Button* Ok
    { Fl_Button* o = new Fl_Button(150, 210, 120, 30, "Apply");
      o->box(FL_GTK_UP_BOX);
      o->color(FL_SELECTION_COLOR);
      o->callback((Fl_Callback*)cb_Apply5);
    } // Fl_Button* o
    { Chart = new Fl_Group(10, 14, 185, 181);
      Chart->box(FL_UP_FRAME);
      { Cm = new Fl_Box(63, 68, 74, 74);
        Cm->box(FL_DIAMOND_DOWN_BOX);
      } // Fl_Box* Cm
      { C3 = new Fl_Box(30, 35, 60, 60);
        C3->box(FL_DIAMOND_DOWN_BOX);
      } // Fl_Box* C3
      { C1 = new Fl_Box(30, 115, 60, 60);
        C1->box(FL_DIAMOND_DOWN_BOX);
      } // Fl_Box* C1
      { C2 = new Fl_Box(110, 115, 60, 60);
        C2->box(FL_DIAMOND_DOWN_BOX);
      } // Fl_Box* C2
      { C4 = new Fl_Box(110, 35, 60, 60);
        C4->box(FL_DIAMOND_DOWN_BOX);
      } // Fl_Box* C4
      Chart->end();
    } // Fl_Group* Chart
    { Sld = new Fl_Group(240, 31, 190, 159);
      { Hmin = new Fl_Value_Slider(240, 31, 30, 159, "Hmin");
        Hmin->type(4);
        Hmin->box(FL_GTK_DOWN_BOX);
        Hmin->color((Fl_Color)14);
        Hmin->labelfont(1);
        Hmin->labelcolor((Fl_Color)1);
        Hmin->maximum(180);
        Hmin->step(1);
        Hmin->textsize(14);
        Hmin->textcolor(7);
        Hmin->callback((Fl_Callback*)cb_Hmin);
        Hmin->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* Hmin
      { Hmax = new Fl_Value_Slider(280, 31, 30, 159, "Hmax");
        Hmax->type(4);
        Hmax->box(FL_GTK_DOWN_BOX);
        Hmax->color((Fl_Color)14);
        Hmax->labelfont(1);
        Hmax->labelcolor((Fl_Color)1);
        Hmax->maximum(180);
        Hmax->step(1);
        Hmax->value(180);
        Hmax->textsize(14);
        Hmax->textcolor(7);
        Hmax->callback((Fl_Callback*)cb_Hmax);
        Hmax->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* Hmax
      { Smin = new Fl_Value_Slider(355, 31, 30, 159, "Smin");
        Smin->type(4);
        Smin->box(FL_GTK_DOWN_BOX);
        Smin->color((Fl_Color)5);
        Smin->labelfont(1);
        Smin->labelcolor((Fl_Color)2);
        Smin->maximum(255);
        Smin->step(1);
        Smin->textsize(14);
        Smin->textcolor(7);
        Smin->callback((Fl_Callback*)cb_Smin);
        Smin->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* Smin
      { Smax = new Fl_Value_Slider(400, 31, 30, 159, "Smax");
        Smax->type(4);
        Smax->box(FL_GTK_DOWN_BOX);
        Smax->color((Fl_Color)5);
        Smax->labelfont(1);
        Smax->labelcolor((Fl_Color)2);
        Smax->maximum(255);
        Smax->step(1);
        Smax->value(255);
        Smax->textsize(14);
        Smax->textcolor(7);
        Smax->callback((Fl_Callback*)cb_Smax);
        Smax->align(FL_ALIGN_TOP_LEFT);
      } // Fl_Value_Slider* Smax
      Sld->end();
    } // Fl_Group* Sld
    { Mode = new Fl_Check_Button(25, 220, 110, 15, "Color Mask");
      Mode->down_box(FL_DOWN_BOX);
      Mode->value(1);
    } // Fl_Check_Button* Mode
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void HSFilterForm::show() {
  changecolor();
window->show();
FirstTime=true;
}

void HSFilterForm::hide() {
  window->hide();
}

void HSFilterForm::changecolor() {
  C1->color(fl_hsv_color(Hmin->value(),Smin->value(), 255));
C2->color(fl_hsv_color(Hmax->value(),Smin->value(), 255));
C3->color(fl_hsv_color(Hmin->value(),Smax->value(), 255));
C4->color(fl_hsv_color(Hmax->value(),Smax->value(), 255));


unsigned char hm, sm;

hm=(Hmax->value()+Hmin->value())/2;
sm=(Smax->value()+Smin->value())/2;


Cm->color(fl_hsv_color(hm,sm,255));

Chart->redraw();
Sld->redraw();
}

void Filter2DForm::cb_Ok9_i(Fl_Return_Button*, void*) {
  p->flt.row=Row->value();
p->flt.col=Col->value();
p->flt.anchorx=X->value();
p->flt.anchory=Y->value();
float *d=Data->GetData();
for(int i=0;i<p->flt.row*p->flt.col;i++)
   p->flt.data[i]=d[i];

hide();
}
void Filter2DForm::cb_Ok9(Fl_Return_Button* o, void* v) {
  ((Filter2DForm*)(o->parent()->user_data()))->cb_Ok9_i(o,v);
}

void Filter2DForm::cb_Apply6_i(Fl_Button*, void*) {
  if(X->value()>=Row->value() || Y->value()>=Row->value()){
  fl_alert("The anchor shoud lie within the kernel");
  return;
}
if(FirstTime==false)
  p->Undo(false);
else
  FirstTime=false;  
p->Filter2D(Row->value(),Col->value(),X->value(),Y->value(),Data->GetData());
}
void Filter2DForm::cb_Apply6(Fl_Button* o, void* v) {
  ((Filter2DForm*)(o->parent()->user_data()))->cb_Apply6_i(o,v);
}

void Filter2DForm::cb_Col_i(Fl_Counter*, void*) {
  if(Data->nCol > Col->value())
     Data->HideCol();
   else
     Data->ShowCol();
}
void Filter2DForm::cb_Col(Fl_Counter* o, void* v) {
  ((Filter2DForm*)(o->parent()->user_data()))->cb_Col_i(o,v);
}

void Filter2DForm::cb_Row_i(Fl_Counter*, void*) {
  if(Data->nRow > Row->value())
     Data->HideRow();
   else
     Data->ShowRow();
}
void Filter2DForm::cb_Row(Fl_Counter* o, void* v) {
  ((Filter2DForm*)(o->parent()->user_data()))->cb_Row_i(o,v);
}

Filter2DForm::Filter2DForm() {
  { Fl_Double_Window* o = window = new Fl_Double_Window(529, 379, "Filter 2D");
    window->color((Fl_Color)31);
    window->user_data((void*)(this));
    window->align(FL_ALIGN_CENTER);
    { Ok = new Fl_Return_Button(395, 335, 120, 30, "Ok");
      Ok->box(FL_GTK_THIN_UP_BOX);
      Ok->color((Fl_Color)30);
      Ok->callback((Fl_Callback*)cb_Ok9);
    } // Fl_Return_Button* Ok
    { Fl_Button* o = new Fl_Button(255, 335, 120, 30, "Apply");
      o->box(FL_GTK_UP_BOX);
      o->color(FL_SELECTION_COLOR);
      o->callback((Fl_Callback*)cb_Apply6);
    } // Fl_Button* o
    { Data = new Fl_MatrixReader(17, 68, 502, 252);
      Data->box(FL_DOWN_BOX);
      Data->color((Fl_Color)19);
      Data->selection_color(FL_BACKGROUND_COLOR);
      Data->labeltype(FL_NORMAL_LABEL);
      Data->labelfont(0);
      Data->labelsize(14);
      Data->labelcolor(FL_FOREGROUND_COLOR);
      Data->align(FL_ALIGN_TOP);
      Data->when(FL_WHEN_RELEASE);
      Data->type(0);
      Data->SetRowCol(p->flt.row,p->flt.col);
      Data->SetData(p->flt.data);
      Data->end();
    } // Fl_MatrixReader* Data
    { Col = new Fl_Counter(20, 30, 56, 20, "Column ");
      Col->type(1);
      Col->minimum(1);
      Col->maximum(9);
      Col->step(1);
      Col->value(3);
      Col->callback((Fl_Callback*)cb_Col);
      Col->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Counter* Col
    { Row = new Fl_Counter(95, 30, 56, 20, "Row");
      Row->type(1);
      Row->minimum(1);
      Row->maximum(9);
      Row->step(1);
      Row->value(3);
      Row->callback((Fl_Callback*)cb_Row);
      Row->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Counter* Row
    { X = new Fl_Counter(190, 30, 56, 20, "Anchor X");
      X->type(1);
      X->minimum(-1);
      X->maximum(9);
      X->step(1);
      X->value(-1);
      X->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Counter* X
    { Y = new Fl_Counter(270, 30, 56, 20, "Anchor Y");
      Y->type(1);
      Y->minimum(-1);
      Y->maximum(9);
      Y->step(1);
      Y->value(-1);
      Y->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Counter* Y
    o->set_modal();
    window->end();
  } // Fl_Double_Window* window
}

void Filter2DForm::show() {
  window->show();
Row->value(p->flt.row);
Col->value(p->flt.col);
X->value(p->flt.anchorx);
Y->value(p->flt.anchory);
Data->SetData(p->flt.data);
FirstTime=true;
}

void Filter2DForm::hide() {
  window->hide();
}
